E Compiler
============

# Description
The *E compiler* is computer software that transforms computer code written in the source language *E* (see *test.e*) into an assembler program in the form of a symbolic notation of commands using [Jasmin](http://jasmin.sourceforge.net). The advantages are optimization and a lower overhead. *Jasmin* is an assembler to create class files from assembler-like syntax using the JVM instruction sets. Moreover, [ANTLR](http://jasmin.sourceforge.net) is used as parser generator for reading, processing, executing and translating the structured text. Therefore, it creates a lexer as well as parser for the grammar *grammar/E.g4*. The workflow works as follows:

1. Lexical analysis: Recognizes words (lexeme) like digits or '+' from the source code with finite automatons (regular expressions). Each lexeme consists of at least one or more characters. Comments are ignored.
2. Syntax analysis: Builds a logical structure (AST) using a top down parser. The grammar corresponds to LL(k) whereby k denotes the lookahead, that means the next production is predicted on the basis of tokens whereby the content of the PDA is taken into account. The PDA processes the input from left to right by calculating a left derivation.
3. Context Analysis: Attributes the AST through declaration analysis and type analysis (ASG). The declaration analysis checks whether a declaration exists before use. So there is an automatic error handling. For example, the type analysis checks whether formal and current parameters match.
4. Synthesis: Creates assembler instructions. Since the grammar is defined recursively, the instructions are generated by a post order traverse. Allocation (components), commitment (mapping from functions to components) and process planning are taken into account. Specifically, expressions such as commands are transformed using the necessary instructions. Then, byte code is generated from it which can be executed in the JVM.

Hash tables are used to enable fast access to identifiers, strings and other constructs. To avoid problems, keywords are reserved and the layout is not ignored. For this reason, the finite automats do not need a lookahead. Furthermore, the context-free grammar is unique, i. e. the parser is deterministic. In this way, mathematical rules are implicitly observed. Before starting the code generation, a global optimization is also carried out. For example, isomorphisms are eliminated. After the code generation, there is a local optimization whereby commands are rearranged.

## Prerequisites
+ [JDK 8](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) or later
+ [ANTLR4](http://www.antlr.org) for reading, processing, executing and translating the structured text
+ [Jasmin](http://jasmin.sourceforge.net) to convert ASCII descriptions of Java classes into binary Java class files, suitable for loading by a Java runtime system
+ [Maven](http://maven.apache.org) to manage this project

## Installation
At first, clone or download this project. Afterwards, go to the terminal and type `mvn install` to create and install the related JAR file. To delete the created folder *target*, the command `mvn clean` must be executed. To execute the unit tests, there is the command `mvn test`.

## Usage
Navigate to the folder *target* and type `java -jar *.jar` to execute the created JAR file. 

For example, to work with the project, it can be imported as a maven project into the IDE *IntelliJ*. Let us assume, for example, that the example rule *test* is to be inserted.

If the grammar is changed, the code must be adapted. To do this, the following commands must be executed after the change:

```
$ cd grammar
$ antlr4 -package com.runekrauss.parser -o ../src/main/java/com/runekrauss/parser/ -no-listener -visitor E.g4
```

Now look into the class *EBaseVisitor* where you will find a method called *visitTest*:

```
public T visitTest(EParser.TestContext ctx) { return visitChildren(ctx); }`
```

This method must be overwritten in the class *EVisitor* with the respective actions to traverse the tree. To test the code, the array in the method *provideCodeExpectedOutput* of the class *CompilerTest* must be extended. To view the corresponding tree, you can use the TestRig tool as follows:

```
$ cd target
$ java -cp classes:antlr-4.7.1-complete.jar org.antlr.v4.gui.TestRig com.runekrauss.parser.E program -gui ../test.e
```

Then, a graphical user interface opens which displays the tree.

## More information
Generate the documentation of this project regarding the special comments with a command in your terminal, for example:

```
$ cd java
$ javadoc -d doc com.runekrauss.compiler
```

Afterwards, you will get a website with helpful information about the code.